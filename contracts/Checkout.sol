pragma solidity ^0.4.11;

import "./DINRegistry.sol";
import "./Orders.sol";
import "zeppelin-solidity/contracts/math/SafeMath.sol";

/** @title Checkout with Ether. */
contract Checkout {
    using SafeMath for uint256;

    DINRegistry public registry;
    Orders public orders;

    // Log Solidity errors
    event LogError(string error);

    /** @dev Constructor.
      * @param _registry The DIN Registry contract address.
      * @param _orders The Orders contract address.
      */
    function Checkout(DINRegistry _registry, Orders _orders) public {
        registry = _registry;
        orders = _orders;
    }

    /** @dev Buy a product.
      * @param DIN The Decentralized Identification Number (DIN) of the product to buy.
      * @param quantity The quantity to buy.
      * @param totalPrice Total price of the purchase, in wei.
      * @param priceValidUntil Expiration time (Unix timestamp).
      * @param merchant The merchant address.
      * @param nonceHash The hash of a nonce generated by a client. The nonce can be used as a proof of purchase.
      * @param v ECDSA signature parameter v.
      * @param r ECDSA signature parameter r.
      * @param s ECDSA signature parameter s.
      * @return orderID A unique ID for the order.
      */
    function buy(
        uint256 DIN,
        uint256 quantity,
        uint256 totalPrice,
        uint256 priceValidUntil,
        address merchant,
        bytes32 nonceHash,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        payable
        public
        returns (uint256)
    {
        address owner = registry.owner(DIN);

        bool valid = isValidOrder(
            DIN,
            quantity,
            totalPrice,
            priceValidUntil,
            merchant,
            owner
            v,
            r,
            s
        );

        if (valid == false) {
            // Return Ether to buyer.
            msg.sender.transfer(msg.value);
            return 0;
        }

        // Transfer Ether to the merchant.
        merchant.transfer(msg.value);

        // Create a new order
        uint256 orderID = orders.createOrder(
            nonceHash,
            msg.sender, // Buyer
            merchant,
            DIN,
            quantity,
            totalPrice
        );

        // Return the unique order ID.
        return orderID;
    }

    /**
      * @dev Verify that an order is valid.
      * @return valid Validity of the order.
      */
    function isValidOrder(
        uint256 DIN,
        uint256 quantity,
        uint256 totalPrice,
        uint256 priceValidUntil,
        address merchant,
        address owner,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) 
        internal 
        constant 
        returns (bool) 
    {
        if (block.timestamp > priceValidUntil) {
            LogError("Offer expired");
            return false;
        }

        if (merchant == address(0x0)) {
            LogError("Invalid merchant");
            return false;
        }

        if (msg.value != totalPrice) {
            LogError("Invalid price");
            return false;
        }

        uint256 unitPrice = totalPrice / quantity;

        // Calculate the hash of the parameters provided by the buyer.
        bytes32 hash = keccak256(DIN, unitPrice, priceValidUntil, merchant);

        // Verify that the DIN owner has signed the provided inputs.
        if (isValidSignature(owner, hash, v, r, s) == false) {
            LogError("Invalid signature");
            return false;
        }

        return true;
    }

    /**
      * @dev Verify that an order signature is valid.
      * @param signer address of signer.
      * @param hash Signed Keccak-256 hash.
      * @param v ECDSA signature parameter v.
      * @param r ECDSA signature parameters r.
      * @param s ECDSA signature parameters s.
      * @return valid Validity of the order signature.
      */
    function isValidSignature(
        address signer,
        bytes32 hash,
        uint8 v,
        bytes32 r,
        bytes32 s
    )
        public
        constant
        returns (bool valid)
    {
        return signer == ecrecover(
            keccak256("\x19Ethereum Signed Message:\n32", hash),
            v,
            r,
            s
        );
    }

}